package quantscale.analytic
import quantscale.fdm.Epsilon
import quantscale.math.Function1D
import scala.math
import scala.math

object JohnsonCND extends Function1D {
  /* erfcx(x) = exp(x^2) erfc(x) function, for real x, written by
   Steven G. Johnson, October 2012.

   This function combines a few different ideas.

   First, for x > 50, it uses a continued-fraction expansion (same as
   for the Faddeeva function, but with algebraic simplifications for z=i*x).

   Second, for 0 <= x <= 50, it uses Chebyshev polynomial approximations,
   but with two twists:

      a) It maps x to y = 4 / (4+x) in [0,1].  This simple transformation,
         inspired by a similar transformation in the octave-forge/specfun
         erfcx by Soren Hauberg, results in much faster Chebyshev convergence
         than other simple transformations I have examined.

      b) Instead of using a single Chebyshev polynomial for the entire
         [0,1] y interval, we break the interval up into 100 equal
         subintervals, with a switch/lookup table, and use much lower
         degree Chebyshev polynomials in each subinterval. This greatly
         improves performance in my tests.

   For x < 0, we use the relationship erfcx(-x) = 2 exp(x^2) - erfc(x),
   with the usual checks for overflow etcetera.

   Performance-wise, it seems to be substantially faster than either
   the SLATEC DERFC function [or an erfcx function derived therefrom]
   or Cody's CALERF function (from netlib.org/specfun), while
   retaining near machine precision in accuracy.  */

  /* Given y100=100*y, where y = 4/(4+x) for x >= 0, compute erfc(x).

     Uses a look-up table of 100 different Chebyshev polynomials
     for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
     with the help of Maple and a little shell script.   This allows
     the Chebyshev polynomials to be of significantly lower degree (about 1/4)
     compared to fitting the whole [0,1] interval with a single polynomial. */

  val RTWO = 1.414213562373095048801688724209e0
  private final def erfcx_y100(y100: Double) : Double = {
    y100.toInt match {
      case 0 => {
        val t = 2*y100 - 1
        return 0.70878032454106438663e-3 + (0.71234091047026302958e-3 + (0.35779077297597742384e-5 + (0.17403143962587937815e-7 + (0.81710660047307788845e-10 + (0.36885022360434957634e-12 + 0.15917038551111111111e-14 * t) * t) * t) * t) * t) * t;
      }
      case 1=> {
        val t = 2*y100 - 3
        return 0.21479143208285144230e-2 + (0.72686402367379996033e-3 + (0.36843175430938995552e-5 + (0.18071841272149201685e-7 + (0.85496449296040325555e-10 + (0.38852037518534291510e-12 + 0.16868473576888888889e-14 * t) * t) * t) * t) * t) * t
      }
      case 2=> {
        val t = 2*y100 - 5
        return 0.36165255935630175090e-2 + (0.74182092323555510862e-3 + (0.37948319957528242260e-5 + (0.18771627021793087350e-7 + (0.89484715122415089123e-10 + (0.40935858517772440862e-12 + 0.17872061464888888889e-14 * t) * t) * t) * t) * t) * t
      }
      case 3=> {
        val t = 2*y100 - 7
        return 0.51154983860031979264e-2 + (0.75722840734791660540e-3 + (0.39096425726735703941e-5 + (0.19504168704300468210e-7 + (0.93687503063178993915e-10 + (0.43143925959079664747e-12 + 0.18939926435555555556e-14 * t) * t) * t) * t) * t) * t
      }
      case 4=> {
        val t = 2*y100 - 9
        return 0.66457513172673049824e-2 + (0.77310406054447454920e-3 + (0.40289510589399439385e-5 + (0.20271233238288381092e-7 + (0.98117631321709100264e-10 + (0.45484207406017752971e-12 + 0.20076352213333333333e-14 * t) * t) * t) * t) * t) * t
      }
      case 5=> {
        val t = 2*y100 - 11
        return 0.82082389970241207883e-2 + (0.78946629611881710721e-3 + (0.41529701552622656574e-5 + (0.21074693344544655714e-7 + (0.10278874108587317989e-9 + (0.47965201390613339638e-12 + 0.21285907413333333333e-14 * t) * t) * t) * t) * t) * t
      }
      case 6=> {
        val t = 2*y100 - 13
        return 0.98039537275352193165e-2 + (0.80633440108342840956e-3 + (0.42819241329736982942e-5 + (0.21916534346907168612e-7 + (0.10771535136565470914e-9 + (0.50595972623692822410e-12 + 0.22573462684444444444e-14 * t) * t) * t) * t) * t) * t
      }
      case 7=> {
        val t = 2*y100 - 15
        return 0.11433927298290302370e-1 + (0.82372858383196561209e-3 + (0.44160495311765438816e-5 + (0.22798861426211986056e-7 + (0.11291291745879239736e-9 + (0.53386189365816880454e-12 + 0.23944209546666666667e-14 * t) * t) * t) * t) * t) * t
      }
      case 8=> {
        val t = 2*y100 - 17
        return 0.13099232878814653979e-1 + (0.84167002467906968214e-3 + (0.45555958988457506002e-5 + (0.23723907357214175198e-7 + (0.11839789326602695603e-9 + (0.56346163067550237877e-12 + 0.25403679644444444444e-14 * t) * t) * t) * t) * t) * t
      }
      case 9=> {
        val t = 2*y100 - 19
        return 0.14800987015587535621e-1 + (0.86018092946345943214e-3 + (0.47008265848816866105e-5 + (0.24694040760197315333e-7 + (0.12418779768752299093e-9 + (0.59486890370320261949e-12 + 0.26957764568888888889e-14 * t) * t) * t) * t) * t) * t
      }
      case 10=> {
        val t = 2*y100 - 21
        return 0.16540351739394069380e-1 + (0.87928458641241463952e-3 + (0.48520195793001753903e-5 + (0.25711774900881709176e-7 + (0.13030128534230822419e-9 + (0.62820097586874779402e-12 + 0.28612737351111111111e-14 * t) * t) * t) * t) * t) * t
      }
      case 11=> {
        val t = 2*y100 - 23
        return 0.18318536789842392647e-1 + (0.89900542647891721692e-3 + (0.50094684089553365810e-5 + (0.26779777074218070482e-7 + (0.13675822186304615566e-9 + (0.66358287745352705725e-12 + 0.30375273884444444444e-14 * t) * t) * t) * t) * t) * t
      }
      case 12=> {
        val t = 2*y100 - 25
        return 0.20136801964214276775e-1 + (0.91936908737673676012e-3 + (0.51734830914104276820e-5 + (0.27900878609710432673e-7 + (0.14357976402809042257e-9 + (0.70114790311043728387e-12 + 0.32252476000000000000e-14 * t) * t) * t) * t) * t) * t
      }
      case 13=> {
        val t = 2*y100 - 27
        return 0.21996459598282740954e-1 + (0.94040248155366777784e-3 + (0.53443911508041164739e-5 + (0.29078085538049374673e-7 + (0.15078844500329731137e-9 + (0.74103813647499204269e-12 + 0.34251892320000000000e-14 * t) * t) * t) * t) * t) * t
      }
      case 14=> {
        val t = 2*y100 - 29
        return 0.23898877187226319502e-1 + (0.96213386835900177540e-3 + (0.55225386998049012752e-5 + (0.30314589961047687059e-7 + (0.15840826497296335264e-9 + (0.78340500472414454395e-12 + 0.36381553564444444445e-14 * t) * t) * t) * t) * t) * t
      }
      case 15=> {
        val t = 2*y100 - 31
        return 0.25845480155298518485e-1 + (0.98459293067820123389e-3 + (0.57082915920051843672e-5 + (0.31613782169164830118e-7 + (0.16646478745529630813e-9 + (0.82840985928785407942e-12 + 0.38649975768888888890e-14 * t) * t) * t) * t) * t) * t
      }
      case 16=> {
        val t = 2*y100 - 33
        return 0.27837754783474696598e-1 + (0.10078108563256892757e-2 + (0.59020366493792212221e-5 + (0.32979263553246520417e-7 + (0.17498524159268458073e-9 + (0.87622459124842525110e-12 + 0.41066206488888888890e-14 * t) * t) * t) * t) * t) * t
      }
      case 17=> {
        val t = 2*y100 - 35
        return 0.29877251304899307550e-1 + (0.10318204245057349310e-2 + (0.61041829697162055093e-5 + (0.34414860359542720579e-7 + (0.18399863072934089607e-9 + (0.92703227366365046533e-12 + 0.43639844053333333334e-14 * t) * t) * t) * t) * t) * t
      }
      case 18=> {
        val t = 2*y100 - 37
        return 0.31965587178596443475e-1 + (0.10566560976716574401e-2 + (0.63151633192414586770e-5 + (0.35924638339521924242e-7 + (0.19353584758781174038e-9 + (0.98102783859889264382e-12 + 0.46381060817777777779e-14 * t) * t) * t) * t) * t) * t
      }
      case 19=> {
        val t = 2*y100 - 39
        return 0.34104450552588334840e-1 + (0.10823541191350532574e-2 + (0.65354356159553934436e-5 + (0.37512918348533521149e-7 + (0.20362979635817883229e-9 + (0.10384187833037282363e-11 + 0.49300625262222222221e-14 * t) * t) * t) * t) * t) * t
      }
      case 20=> {
        val t = 2*y100 - 41
        return 0.36295603928292425716e-1 + (0.11089526167995268200e-2 + (0.67654845095518363577e-5 + (0.39184292949913591646e-7 + (0.21431552202133775150e-9 + (0.10994259106646731797e-11 + 0.52409949102222222221e-14 * t) * t) * t) * t) * t) * t
      }
      case 21=> {
        val t = 2*y100 - 43
        return 0.38540888038840509795e-1 + (0.11364917134175420009e-2 + (0.70058230641246312003e-5 + (0.40943644083718586939e-7 + (0.22563034723692881631e-9 + (0.11642841011361992885e-11 + 0.55721092871111111110e-14 * t) * t) * t) * t) * t) * t
      }
      case 22=> {
        val t = 2*y100 - 45
        return 0.40842225954785960651e-1 + (0.11650136437945673891e-2 + (0.72569945502343006619e-5 + (0.42796161861855042273e-7 + (0.23761401711005024162e-9 + (0.12332431172381557035e-11 + 0.59246802364444444445e-14 * t) * t) * t) * t) * t) * t
      }
      case 23=> {
        val t = 2*y100 - 47
        return 0.43201627431540222422e-1 + (0.11945628793917272199e-2 + (0.75195743532849206263e-5 + (0.44747364553960993492e-7 + (0.25030885216472953674e-9 + (0.13065684400300476484e-11 + 0.63000532853333333334e-14 * t) * t) * t) * t) * t) * t
      }
      case 24=> {
        val t = 2*y100 - 49
        return 0.45621193513810471438e-1 + (0.12251862608067529503e-2 + (0.77941720055551920319e-5 + (0.46803119830954460212e-7 + (0.26375990983978426273e-9 + (0.13845421370977119765e-11 + 0.66996477404444444445e-14 * t) * t) * t) * t) * t) * t
      }
      case 25=> {
        val t = 2*y100 - 51
        return 0.48103121413299865517e-1 + (0.12569331386432195113e-2 + (0.80814333496367673980e-5 + (0.48969667335682018324e-7 + (0.27801515481905748484e-9 + (0.14674637611609884208e-11 + 0.71249589351111111110e-14 * t) * t) * t) * t) * t) * t
      }
      case 26=> {
        val t = 2*y100 - 53
        return 0.50649709676983338501e-1 + (0.12898555233099055810e-2 + (0.83820428414568799654e-5 + (0.51253642652551838659e-7 + (0.29312563849675507232e-9 + (0.15556512782814827846e-11 + 0.75775607822222222221e-14 * t) * t) * t) * t) * t) * t
      }
      case 27=> {
        val t = 2*y100 - 55
        return 0.53263363664388864181e-1 + (0.13240082443256975769e-2 + (0.86967260015007658418e-5 + (0.53662102750396795566e-7 + (0.30914568786634796807e-9 + (0.16494420240828493176e-11 + 0.80591079644444444445e-14 * t) * t) * t) * t) * t) * t
      }
      case 28=> {
        val t = 2*y100 - 57
        return 0.55946601353500013794e-1 + (0.13594491197408190706e-2 + (0.90262520233016380987e-5 + (0.56202552975056695376e-7 + (0.32613310410503135996e-9 + (0.17491936862246367398e-11 + 0.85713381688888888890e-14 * t) * t) * t) * t) * t) * t
      }
      case 29=> {
        val t = 2*y100 - 59
        return 0.58702059496154081813e-1 + (0.13962391363223647892e-2 + (0.93714365487312784270e-5 + (0.58882975670265286526e-7 + (0.34414937110591753387e-9 + (0.18552853109751857859e-11 + 0.91160736711111111110e-14 * t) * t) * t) * t) * t) * t
      }
      case 30=> {
        val t = 2*y100 - 61
        return 0.61532500145144778048e-1 + (0.14344426411912015247e-2 + (0.97331446201016809696e-5 + (0.61711860507347175097e-7 + (0.36325987418295300221e-9 + (0.19681183310134518232e-11 + 0.96952238400000000000e-14 * t) * t) * t) * t) * t) * t
      }
      case 31=> {
        val t = 2*y100 - 63
        return 0.64440817576653297993e-1 + (0.14741275456383131151e-2 + (0.10112293819576437838e-4 + (0.64698236605933246196e-7 + (0.38353412915303665586e-9 + (0.20881176114385120186e-11 + 0.10310784480000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 32=> {
        val t = 2*y100 - 65
        return 0.67430045633130393282e-1 + (0.15153655418916540370e-2 + (0.10509857606888328667e-4 + (0.67851706529363332855e-7 + (0.40504602194811140006e-9 + (0.22157325110542534469e-11 + 0.10964842115555555556e-13 * t) * t) * t) * t) * t) * t
      }
      case 33=> {
        val t = 2*y100 - 67
        return 0.70503365513338850709e-1 + (0.15582323336495709827e-2 + (0.10926868866865231089e-4 + (0.71182482239613507542e-7 + (0.42787405890153386710e-9 + (0.23514379522274416437e-11 + 0.11659571751111111111e-13 * t) * t) * t) * t) * t) * t
      }
      case 34=> {
        val t = 2*y100 - 69
        return 0.73664114037944596353e-1 + (0.16028078812438820413e-2 + (0.11364423678778207991e-4 + (0.74701423097423182009e-7 + (0.45210162777476488324e-9 + (0.24957355004088569134e-11 + 0.12397238257777777778e-13 * t) * t) * t) * t) * t) * t
      }
      case 35=> {
        val t = 2*y100 - 71
        return 0.76915792420819562379e-1 + (0.16491766623447889354e-2 + (0.11823685320041302169e-4 + (0.78420075993781544386e-7 + (0.47781726956916478925e-9 + (0.26491544403815724749e-11 + 0.13180196462222222222e-13 * t) * t) * t) * t) * t) * t
      }
      case 36=> {
        val t = 2*y100 - 73
        return 0.80262075578094612819e-1 + (0.16974279491709504117e-2 + (0.12305888517309891674e-4 + (0.82350717698979042290e-7 + (0.50511496109857113929e-9 + (0.28122528497626897696e-11 + 0.14010889635555555556e-13 * t) * t) * t) * t) * t) * t
      }
      case 37=> {
        val t = 2*y100 - 75
        return 0.83706822008980357446e-1 + (0.17476561032212656962e-2 + (0.12812343958540763368e-4 + (0.86506399515036435592e-7 + (0.53409440823869467453e-9 + (0.29856186620887555043e-11 + 0.14891851591111111111e-13 * t) * t) * t) * t) * t) * t
      }
      case 38=> {
        val t = 2*y100 - 77
        return 0.87254084284461718231e-1 + (0.17999608886001962327e-2 + (0.13344443080089492218e-4 + (0.90900994316429008631e-7 + (0.56486134972616465316e-9 + (0.31698707080033956934e-11 + 0.15825697795555555556e-13 * t) * t) * t) * t) * t) * t
      }
      case 39=> {
        val t = 2*y100 - 79
        return 0.90908120182172748487e-1 + (0.18544478050657699758e-2 + (0.13903663143426120077e-4 + (0.95549246062549906177e-7 + (0.59752787125242054315e-9 + (0.33656597366099099413e-11 + 0.16815130613333333333e-13 * t) * t) * t) * t) * t) * t
      }
      case 40=> {
        val t = 2*y100 - 81
        return 0.94673404508075481121e-1 + (0.19112284419887303347e-2 + (0.14491572616545004930e-4 + (0.10046682186333613697e-6 + (0.63221272959791000515e-9 + (0.35736693975589130818e-11 + 0.17862931591111111111e-13 * t) * t) * t) * t) * t) * t
      }
      case 41=> {
        val t = 2*y100 - 83
        return 0.98554641648004456555e-1 + (0.19704208544725622126e-2 + (0.15109836875625443935e-4 + (0.10567036667675984067e-6 + (0.66904168640019354565e-9 + (0.37946171850824333014e-11 + 0.18971959040000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 42=> {
        val t = 2*y100 - 85
        return 0.10255677889470089531e0 + (0.20321499629472857418e-2 + (0.15760224242962179564e-4 + (0.11117756071353507391e-6 + (0.70814785110097658502e-9 + (0.40292553276632563925e-11 + 0.20145143075555555556e-13 * t) * t) * t) * t) * t) * t
      }
      case 43=> {
        val t = 2*y100 - 87
        return 0.10668502059865093318e0 + (0.20965479776148731610e-2 + (0.16444612377624983565e-4 + (0.11700717962026152749e-6 + (0.74967203250938418991e-9 + (0.42783716186085922176e-11 + 0.21385479360000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 44=> {
        val t = 2*y100 - 89
        return 0.11094484319386444474e0 + (0.21637548491908170841e-2 + (0.17164995035719657111e-4 + (0.12317915750735938089e-6 + (0.79376309831499633734e-9 + (0.45427901763106353914e-11 + 0.22696025653333333333e-13 * t) * t) * t) * t) * t) * t
      }
      case 45=> {
        val t = 2*y100 - 91
        return 0.11534201115268804714e0 + (0.22339187474546420375e-2 + (0.17923489217504226813e-4 + (0.12971465288245997681e-6 + (0.84057834180389073587e-9 + (0.48233721206418027227e-11 + 0.24079890062222222222e-13 * t) * t) * t) * t) * t) * t
      }
      case 46=> {
        val t = 2*y100 - 93
        return 0.11988259392684094740e0 + (0.23071965691918689601e-2 + (0.18722342718958935446e-4 + (0.13663611754337957520e-6 + (0.89028385488493287005e-9 + (0.51210161569225846701e-11 + 0.25540227111111111111e-13 * t) * t) * t) * t) * t) * t
      }
      case 47=> {
        val t = 2*y100 - 95
        return 0.12457298393509812907e0 + (0.23837544771809575380e-2 + (0.19563942105711612475e-4 + (0.14396736847739470782e-6 + (0.94305490646459247016e-9 + (0.54366590583134218096e-11 + 0.27080225920000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 48=> {
        val t = 2*y100 - 97
        return 0.12941991566142438816e0 + (0.24637684719508859484e-2 + (0.20450821127475879816e-4 + (0.15173366280523906622e-6 + (0.99907632506389027739e-9 + (0.57712760311351625221e-11 + 0.28703099555555555556e-13 * t) * t) * t) * t) * t) * t
      }
      case 49=> {
        val t = 2*y100 - 99
        return 0.13443048593088696613e0 + (0.25474249981080823877e-2 + (0.21385669591362915223e-4 + (0.15996177579900443030e-6 + (0.10585428844575134013e-8 + (0.61258809536787882989e-11 + 0.30412080142222222222e-13 * t) * t) * t) * t) * t) * t
      }
      case 50=> {
        val t = 2*y100 - 101
        return 0.13961217543434561353e0 + (0.26349215871051761416e-2 + (0.22371342712572567744e-4 + (0.16868008199296822247e-6 + (0.11216596910444996246e-8 + (0.65015264753090890662e-11 + 0.32210394506666666666e-13 * t) * t) * t) * t) * t) * t
      }
      case 51=> {
        val t = 2*y100 - 103
        return 0.14497287157673800690e0 + (0.27264675383982439814e-2 + (0.23410870961050950197e-4 + (0.17791863939526376477e-6 + (0.11886425714330958106e-8 + (0.68993039665054288034e-11 + 0.34101266222222222221e-13 * t) * t) * t) * t) * t) * t
      }
      case 52=> {
        val t = 2*y100 - 105
        return 0.15052089272774618151e0 + (0.28222846410136238008e-2 + (0.24507470422713397006e-4 + (0.18770927679626136909e-6 + (0.12597184587583370712e-8 + (0.73203433049229821618e-11 + 0.36087889048888888890e-13 * t) * t) * t) * t) * t) * t
      }
      case 53=> {
        val t = 2*y100 - 107
        return 0.15626501395774612325e0 + (0.29226079376196624949e-2 + (0.25664553693768450545e-4 + (0.19808568415654461964e-6 + (0.13351257759815557897e-8 + (0.77658124891046760667e-11 + 0.38173420035555555555e-13 * t) * t) * t) * t) * t) * t
      }
      case 54=> {
        val t = 2*y100 - 109
        return 0.16221449434620737567e0 + (0.30276865332726475672e-2 + (0.26885741326534564336e-4 + (0.20908350604346384143e-6 + (0.14151148144240728728e-8 + (0.82369170665974313027e-11 + 0.40360957457777777779e-13 * t) * t) * t) * t) * t) * t
      }
      case 55=> {
        val t = 2*y100 - 111
        return 0.16837910595412130659e0 + (0.31377844510793082301e-2 + (0.28174873844911175026e-4 + (0.22074043807045782387e-6 + (0.14999481055996090039e-8 + (0.87348993661930809254e-11 + 0.42653528977777777779e-13 * t) * t) * t) * t) * t) * t
      }
      case 56=> {
        val t = 2*y100 - 113
        return 0.17476916455659369953e0 + (0.32531815370903068316e-2 + (0.29536024347344364074e-4 + (0.23309632627767074202e-6 + (0.15899007843582444846e-8 + (0.92610375235427359475e-11 + 0.45054073102222222221e-13 * t) * t) * t) * t) * t) * t
      }
      case 57=> {
        val t = 2*y100 - 115
        return 0.18139556223643701364e0 + (0.33741744168096996041e-2 + (0.30973511714709500836e-4 + (0.24619326937592290996e-6 + (0.16852609412267750744e-8 + (0.98166442942854895573e-11 + 0.47565418097777777779e-13 * t) * t) * t) * t) * t) * t
      }
      case 58=> {
        val t = 2*y100 - 117
        return 0.18826980194443664549e0 + (0.35010775057740317997e-2 + (0.32491914440014267480e-4 + (0.26007572375886319028e-6 + (0.17863299617388376116e-8 + (0.10403065638343878679e-10 + 0.50190265831111111110e-13 * t) * t) * t) * t) * t) * t
      }
      case 59=> {
        val t = 2*y100 - 119
        return 0.19540403413693967350e0 + (0.36342240767211326315e-2 + (0.34096085096200907289e-4 + (0.27479061117017637474e-6 + (0.18934228504790032826e-8 + (0.11021679075323598664e-10 + 0.52931171733333333334e-13 * t) * t) * t) * t) * t) * t
      }
      case 60=> {
        val t = 2*y100 - 121
        return 0.20281109560651886959e0 + (0.37739673859323597060e-2 + (0.35791165457592409054e-4 + (0.29038742889416172404e-6 + (0.20068685374849001770e-8 + (0.11673891799578381999e-10 + 0.55790523093333333334e-13 * t) * t) * t) * t) * t) * t
      }
      case 61=> {
        val t = 2*y100 - 123
        return 0.21050455062669334978e0 + (0.39206818613925652425e-2 + (0.37582602289680101704e-4 + (0.30691836231886877385e-6 + (0.21270101645763677824e-8 + (0.12361138551062899455e-10 + 0.58770520160000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 62=> {
        val t = 2*y100 - 125
        return 0.21849873453703332479e0 + (0.40747643554689586041e-2 + (0.39476163820986711501e-4 + (0.32443839970139918836e-6 + (0.22542053491518680200e-8 + (0.13084879235290858490e-10 + 0.61873153262222222221e-13 * t) * t) * t) * t) * t) * t
      }
      case 63=> {
        val t = 2*y100 - 127
        return 0.22680879990043229327e0 + (0.42366354648628516935e-2 + (0.41477956909656896779e-4 + (0.34300544894502810002e-6 + (0.23888264229264067658e-8 + (0.13846596292818514601e-10 + 0.65100183751111111110e-13 * t) * t) * t) * t) * t) * t
      }
      case 64=> {
        val t = 2*y100 - 129
        return 0.23545076536988703937e0 + (0.44067409206365170888e-2 + (0.43594444916224700881e-4 + (0.36268045617760415178e-6 + (0.25312606430853202748e-8 + (0.14647791812837903061e-10 + 0.68453122631111111110e-13 * t) * t) * t) * t) * t) * t
      }
      case 65=> {
        val t = 2*y100 - 131
        return 0.24444156740777432838e0 + (0.45855530511605787178e-2 + (0.45832466292683085475e-4 + (0.38352752590033030472e-6 + (0.26819103733055603460e-8 + (0.15489984390884756993e-10 + 0.71933206364444444445e-13 * t) * t) * t) * t) * t) * t
      }
      case 66=> {
        val t = 2*y100 - 133
        return 0.25379911500634264643e0 + (0.47735723208650032167e-2 + (0.48199253896534185372e-4 + (0.40561404245564732314e-6 + (0.28411932320871165585e-8 + (0.16374705736458320149e-10 + 0.75541379822222222221e-13 * t) * t) * t) * t) * t) * t
      }
      case 67=> {
        val t = 2*y100 - 135
        return 0.26354234756393613032e0 + (0.49713289477083781266e-2 + (0.50702455036930367504e-4 + (0.42901079254268185722e-6 + (0.30095422058900481753e-8 + (0.17303497025347342498e-10 + 0.79278273368888888890e-13 * t) * t) * t) * t) * t) * t
      }
      case 68=> {
        val t = 2*y100 - 137
        return 0.27369129607732343398e0 + (0.51793846023052643767e-2 + (0.53350152258326602629e-4 + (0.45379208848865015485e-6 + (0.31874057245814381257e-8 + (0.18277905010245111046e-10 + 0.83144182364444444445e-13 * t) * t) * t) * t) * t) * t
      }
      case 69=> {
        val t = 2*y100 - 139
        return 0.28426714781640316172e0 + (0.53983341916695141966e-2 + (0.56150884865255810638e-4 + (0.48003589196494734238e-6 + (0.33752476967570796349e-8 + (0.19299477888083469086e-10 + 0.87139049137777777779e-13 * t) * t) * t) * t) * t) * t
      }
      case 70=> {
        val t = 2*y100 - 141
        return 0.29529231465348519920e0 + (0.56288077305420795663e-2 + (0.59113671189913307427e-4 + (0.50782393781744840482e-6 + (0.35735475025851713168e-8 + (0.20369760937017070382e-10 + 0.91262442613333333334e-13 * t) * t) * t) * t) * t) * t
      }
      case 71=> {
        val t = 2*y100 - 143
        return 0.30679050522528838613e0 + (0.58714723032745403331e-2 + (0.62248031602197686791e-4 + (0.53724185766200945789e-6 + (0.37827999418960232678e-8 + (0.21490291930444538307e-10 + 0.95513539182222222221e-13 * t) * t) * t) * t) * t) * t
      }
      case 72=> {
        val t = 2*y100 - 145
        return 0.31878680111173319425e0 + (0.61270341192339103514e-2 + (0.65564012259707640976e-4 + (0.56837930287837738996e-6 + (0.40035151353392378882e-8 + (0.22662596341239294792e-10 + 0.99891109760000000000e-13 * t) * t) * t) * t) * t) * t
      }
      case 73=> {
        val t = 2*y100 - 147
        return 0.33130773722152622027e0 + (0.63962406646798080903e-2 + (0.69072209592942396666e-4 + (0.60133006661885941812e-6 + (0.42362183765883466691e-8 + (0.23888182347073698382e-10 + 0.10439349811555555556e-12 * t) * t) * t) * t) * t) * t
      }
      case 74=> {
        val t = 2*y100 - 149
        return 0.34438138658041336523e0 + (0.66798829540414007258e-2 + (0.72783795518603561144e-4 + (0.63619220443228800680e-6 + (0.44814499336514453364e-8 + (0.25168535651285475274e-10 + 0.10901861383111111111e-12 * t) * t) * t) * t) * t) * t
      }
      case 75=> {
        val t = 2*y100 - 151
        return 0.35803744972380175583e0 + (0.69787978834882685031e-2 + (0.76710543371454822497e-4 + (0.67306815308917386747e-6 + (0.47397647975845228205e-8 + (0.26505114141143050509e-10 + 0.11376390933333333333e-12 * t) * t) * t) * t) * t) * t
      }
      case 76=> {
        val t = 2*y100 - 153
        return 0.37230734890119724188e0 + (0.72938706896461381003e-2 + (0.80864854542670714092e-4 + (0.71206484718062688779e-6 + (0.50117323769745883805e-8 + (0.27899342394100074165e-10 + 0.11862637614222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 77=> {
        val t = 2*y100 - 155
        return 0.38722432730555448223e0 + (0.76260375162549802745e-2 + (0.85259785810004603848e-4 + (0.75329383305171327677e-6 + (0.52979361368388119355e-8 + (0.29352606054164086709e-10 + 0.12360253370666666667e-12 * t) * t) * t) * t) * t) * t
      }
      case 78=> {
        val t = 2*y100 - 157
        return 0.40282355354616940667e0 + (0.79762880915029728079e-2 + (0.89909077342438246452e-4 + (0.79687137961956194579e-6 + (0.55989731807360403195e-8 + (0.30866246101464869050e-10 + 0.12868841946666666667e-12 * t) * t) * t) * t) * t) * t
      }
      case 79=> {
        val t = 2*y100 - 159
        return 0.41914223158913787649e0 + (0.83456685186950463538e-2 + (0.94827181359250161335e-4 + (0.84291858561783141014e-6 + (0.59154537751083485684e-8 + (0.32441553034347469291e-10 + 0.13387957943111111111e-12 * t) * t) * t) * t) * t) * t
      }
      case 80=> {
        val t = 2*y100 - 161
        return 0.43621971639463786896e0 + (0.87352841828289495773e-2 + (0.10002929142066799966e-3 + (0.89156148280219880024e-6 + (0.62480008150788597147e-8 + (0.34079760983458878910e-10 + 0.13917107176888888889e-12 * t) * t) * t) * t) * t) * t
      }
      case 81=> {
        val t = 2*y100 - 163
        return 0.45409763548534330981e0 + (0.91463027755548240654e-2 + (0.10553137232446167258e-3 + (0.94293113464638623798e-6 + (0.65972492312219959885e-8 + (0.35782041795476563662e-10 + 0.14455745872000000000e-12 * t) * t) * t) * t) * t) * t
      }
      case 82=> {
        val t = 2*y100 - 165
        return 0.47282001668512331468e0 + (0.95799574408860463394e-2 + (0.11135019058000067469e-3 + (0.99716373005509038080e-6 + (0.69638453369956970347e-8 + (0.37549499088161345850e-10 + 0.15003280712888888889e-12 * t) * t) * t) * t) * t) * t
      }
      case 83=> {
        val t = 2*y100 - 167
        return 0.49243342227179841649e0 + (0.10037550043909497071e-1 + (0.11750334542845234952e-3 + (0.10544006716188967172e-5 + (0.73484461168242224872e-8 + (0.39383162326435752965e-10 + 0.15559069118222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 84=> {
        val t = 2*y100 - 169
        return 0.51298708979209258326e0 + (0.10520454564612427224e-1 + (0.12400930037494996655e-3 + (0.11147886579371265246e-5 + (0.77517184550568711454e-8 + (0.41283980931872622611e-10 + 0.16122419680000000000e-12 * t) * t) * t) * t) * t) * t
      }
      case 85=> {
        val t = 2*y100 - 171
        return 0.53453307979101369843e0 + (0.11030120618800726938e-1 + (0.13088741519572269581e-3 + (0.11784797595374515432e-5 + (0.81743383063044825400e-8 + (0.43252818449517081051e-10 + 0.16692592640000000000e-12 * t) * t) * t) * t) * t) * t
      }
      case 86=> {
        val t = 2*y100 - 173
        return 0.55712643071169299478e0 + (0.11568077107929735233e-1 + (0.13815797838036651289e-3 + (0.12456314879260904558e-5 + (0.86169898078969313597e-8 + (0.45290446811539652525e-10 + 0.17268801084444444444e-12 * t) * t) * t) * t) * t) * t
      }
      case 87=> {
        val t = 2*y100 - 175
        return 0.58082532122519320968e0 + (0.12135935999503877077e-1 + (0.14584223996665838559e-3 + (0.13164068573095710742e-5 + (0.90803643355106020163e-8 + (0.47397540713124619155e-10 + 0.17850211608888888889e-12 * t) * t) * t) * t) * t) * t
      }
      case 88=> {
        val t = 2*y100 - 177
        return 0.60569124025293375554e0 + (0.12735396239525550361e-1 + (0.15396244472258863344e-3 + (0.13909744385382818253e-5 + (0.95651595032306228245e-8 + (0.49574672127669041550e-10 + 0.18435945564444444444e-12 * t) * t) * t) * t) * t) * t
      }
      case 89=> {
        val t = 2*y100 - 179
        return 0.63178916494715716894e0 + (0.13368247798287030927e-1 + (0.16254186562762076141e-3 + (0.14695084048334056083e-5 + (0.10072078109604152350e-7 + (0.51822304995680707483e-10 + 0.19025081422222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 90=> {
        val t = 2*y100 - 181
        return 0.65918774689725319200e0 + (0.14036375850601992063e-1 + (0.17160483760259706354e-3 + (0.15521885688723188371e-5 + (0.10601827031535280590e-7 + (0.54140790105837520499e-10 + 0.19616655146666666667e-12 * t) * t) * t) * t) * t) * t
      }
      case 91=> {
        val t = 2*y100 - 183
        return 0.68795950683174433822e0 + (0.14741765091365869084e-1 + (0.18117679143520433835e-3 + (0.16392004108230585213e-5 + (0.11155116068018043001e-7 + (0.56530360194925690374e-10 + 0.20209663662222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 92=> {
        val t = 2*y100 - 185
        return 0.71818103808729967036e0 + (0.15486504187117112279e-1 + (0.19128428784550923217e-3 + (0.17307350969359975848e-5 + (0.11732656736113607751e-7 + (0.58991125287563833603e-10 + 0.20803065333333333333e-12 * t) * t) * t) * t) * t) * t
      }
      case 93=> {
        val t = 2*y100 - 187
        return 0.74993321911726254661e0 + (0.16272790364044783382e-1 + (0.20195505163377912645e-3 + (0.18269894883203346953e-5 + (0.12335161021630225535e-7 + (0.61523068312169087227e-10 + 0.21395783431111111111e-12 * t) * t) * t) * t) * t) * t
      }
      case 94=> {
        val t = 2*y100 - 189
        return 0.78330143531283492729e0 + (0.17102934132652429240e-1 + (0.21321800585063327041e-3 + (0.19281661395543913713e-5 + (0.12963340087354341574e-7 + (0.64126040998066348872e-10 + 0.21986708942222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 95=> {
        val t = 2*y100 - 191
        return 0.81837581041023811832e0 + (0.17979364149044223802e-1 + (0.22510330592753129006e-3 + (0.20344732868018175389e-5 + (0.13617902941839949718e-7 + (0.66799760083972474642e-10 + 0.22574701262222222222e-12 * t) * t) * t) * t) * t) * t
      }
      case 96=> {
        val t = 2*y100 - 193
        return 0.85525144775685126237e0 + (0.18904632212547561026e-1 + (0.23764237370371255638e-3 + (0.21461248251306387979e-5 + (0.14299555071870523786e-7 + (0.69543803864694171934e-10 + 0.23158593688888888889e-12 * t) * t) * t) * t) * t) * t
      }
      case 97=> {
        val t = 2*y100 - 195
        return 0.89402868170849933734e0 + (0.19881418399127202569e-1 + (0.25086793128395995798e-3 + (0.22633402747585233180e-5 + (0.15008997042116532283e-7 + (0.72357609075043941261e-10 + 0.23737194737777777778e-12 * t) * t) * t) * t) * t) * t
      }
      case 98=> {
        val t = 2*y100 - 197
        return 0.93481333942870796363e0 + (0.20912536329780368893e-1 + (0.26481403465998477969e-3 + (0.23863447359754921676e-5 + (0.15746923065472184451e-7 + (0.75240468141720143653e-10 + 0.24309291271111111111e-12 * t) * t) * t) * t) * t) * t
      }
      case 99=> {
        val t = 2*y100 - 199
        return 0.97771701335885035464e0 + (0.22000938572830479551e-1 + (0.27951610702682383001e-3 + (0.25153688325245314530e-5 + (0.16514019547822821453e-7 + (0.78191526829368231251e-10 + 0.24873652355555555556e-12 * t) * t) * t) * t) * t) * t
      }
      // we only get here if y = 1, i.e. |x| < 4*eps, in which case
      // erfcx is within 1e-15 of 1..
      case _ => return 1.0
    }
  }

  final def erfcx(x: Double) : Double = {
    if (x >= 0) {
      if (x > 50) { // continued-fraction expansion is faster
        val ispi : Double = 0.56418958354775628694807945156; // 1 / sqrt(pi)
        if (x > 5e7) // 1-term expansion, important to avoid overflow
          return ispi / x;
        /* 5-term expansion (rely on compiler for CSE), simplified from:
                  ispi / (x+0.5/(x+1/(x+1.5/(x+2/x))))  */
        return ispi*((x*x) * (x*x+4.5) + 2) / (x * ((x*x) * (x*x+5) + 3.75));
      }
      return erfcx_y100(400/(4+x));
    }
    else
      return if (x < -26.7) Double.MaxValue else if (x < -6.1) 2*math.exp(x*x) else 2*math.exp(x*x) - erfcx_y100(400/(4-x));
  }


  final def value(z: Double) : Double = {
    var x = z/RTWO
    if (x*x > 750) {// underflow
      return if (x >= 0) 1.0 else 0.0
    }
    if (x < -26.7) return Double.MinValue
    if (x <= 0) {
      x = -x
      if (x > 50) { // continued-fraction expansion is faster
      val ispi : Double = 0.56418958354775628694807945156; // 1 / sqrt(pi)
        if (x > 5e7) // 1-term expansion, important to avoid overflow
          return ispi / x;
        /* 5-term expansion (rely on compiler for CSE), simplified from:
                  ispi / (x+0.5/(x+1/(x+1.5/(x+2/x))))  */
        return 0.5*NormalDistribution.denormalizedValue(z)*ispi*((x*x) * (x*x+4.5) + 2) / (x * ((x*x) * (x*x+5) + 3.75));
      }
      return 0.5*NormalDistribution.denormalizedValue(z)*erfcx_y100(400/(4+x));
    }
    else
      return if (x > 6.1) 1.0 else 1.0 - 0.5*NormalDistribution.denormalizedValue(z)*erfcx_y100(400/(4+x));


    //return 1.0-0.5*math.exp(-x*x)*erfcx(x)
  }

}
/**
 * Reference: Cody, W.D. (1993). ALGORITHM 715: SPECFUN - A Portable
 * FORTRAN Package of Special Function Routines and Test Drivers" ACM
 * Transactions on Mathematical Software. 19, 22-32.
 *
 * This function evaluates the normal distribution function: The main
 * computation evaluates near-minimax approximations derived from those
 * in "Rational Chebyshev approximations for the error function" by W.
 * J. Cody, Math. Comp., 1969, 631-637. This transportable program uses
 * rational functions that theoretically approximate the normal
 * distribution function to at least 18 significant decimal digits. The
 * accuracy achieved depends on the arithmetic system, the compiler, the
 * intrinsic functions, and proper selection of the machine-dependent
 * constants.
 *
 *
 * Mathematical Constants:
 *
 * sqrpi = 1 / sqrt(2*pi), root32 = sqrt(32), thrsh = the argument for
 * which pnorm(thrsh,0,1) = 0.75.
 */

object CodyCND extends Function1D {

  private final val DBL_EPSILON = Epsilon.MACHINE_EPSILON; //2.2204460492503131e-16;
  private final val DBL_MIN = Double.MinValue; //2.2250738585072014e-308;

  private final val c = Array(0.39894151208813466764,
    8.8831497943883759412, 93.506656132177855979,
    597.27027639480026226, 2494.5375852903726711,
    6848.1904505362823326, 11602.651437647350124,
    9842.7148383839780218, 1.0765576773720192317e-8);

  private final val d = Array(22.266688044328115691,
    235.38790178262499861, 1519.377599407554805,
    6485.558298266760755, 18615.571640885098091,
    34900.952721145977266, 38912.003286093271411,
    19685.429676859990727);

  private final val p = Array(0.21589853405795699,
    0.1274011611602473639, 0.022235277870649807,
    0.001421619193227893466, 2.9112874951168792e-5,
    0.02307344176494017303);

  private final val q = Array(1.28426009614491121,
    0.468238212480865118, 0.0659881378689285515,
    0.00378239633202758244, 7.29751555083966205e-5);

  private final val a = Array(2.2352520354606839287,
    161.02823106855587881, 1067.6894854603709582,
    18154.981253343561249, 0.065682337918207449113);

  private final val b = Array(47.20258190468824187,
    976.09855173777669322, 10260.932208618978205,
    45507.789335026729956);

  final val one = 1.0;
  final val half = 0.5;
  final val zero = 0.0;
  final val sixten = 1.6;
  final val sqrpi = 0.39894228040143267794;
  final val thrsh = 0.66291;
  final val root32 = 5.656854248;

  def pnorms(x: Double): Double = {

    var xden: Double = 0;
    var temp: Double = 0;
    var xnum: Double = 0;
    var result: Double = 0;
    var ccum: Double = 0;
    var del: Double = 0;
    val min = DBL_MIN;
    val eps = DBL_EPSILON * .5;
    var xsq: Double = 0;
    var y: Double = 0;
    var i: Int = 0;

    y = Math.abs(x);
    if (y <= thrsh) {
      /* Evaluate pnorm for |z| <= 0.66291 */
      xsq = zero;
      if (y > eps) {
        xsq = x * x;
      }
      xnum = a(4) * xsq;
      xden = xsq;
      i = 1;
      while (i <= 3) {
        xnum = (xnum + a(i - 1)) * xsq;
        xden = (xden + b(i - 1)) * xsq;
        i += 1;
      }
      result = x * (xnum + a(3)) / (xden + b(3));
      temp = result;
      result = half + temp;
      ccum = half - temp;
    } else if (y <= root32) {
      /* Evaluate pnorm for 0.66291 <= |z| <= sqrt(32) */
      xnum = c(8) * y;
      xden = y;
      i = 1;
      while (i <= 7) {
        xnum = (xnum + c(i - 1)) * y;
        xden = (xden + d(i - 1)) * y;
        i += 1;
      }
      result = (xnum + c(7)) / (xden + d(7));
      xsq = fint(y * sixten) / sixten;
      del = (y - xsq) * (y + xsq);
      result = Math.exp(-xsq * xsq * half) * Math.exp(-del * half) * result;
      ccum = one - result;
      if (x > zero) {
        temp = result;
        result = ccum;
        ccum = temp;
      }
    } else {
      /* Evaluate pnorm for |z| > sqrt(32) */
      result = zero;
      xsq = one / (x * x);
      xnum = p(5) * xsq;
      xden = xsq;
      i = 1;
      while (i <= 4) {
        xnum = (xnum + p(i - 1)) * xsq;
        xden = (xden + q(i - 1)) * xsq;
        i += 1;
      }
      result = xsq * (xnum + p(4)) / (xden + q(4));
      result = (sqrpi - result) / y;
      xsq = fint(x * sixten) / sixten;
      del = (x - xsq) * (x + xsq);
      result = Math.exp(-xsq * xsq * half) * Math.exp(-del * half) * result;
      ccum = one - result;
      if (x > zero) {
        temp = result;
        result = ccum;
        ccum = temp;
      }
    }
    if (result < min) {
      result = 0.0;
    }
    if (ccum < min) {
      ccum = 0.0;
    }
    return result;
  }

  private def fint(x: Double): Double =

    if (x >= 0.0) StrictMath.floor(x) else -StrictMath.floor(-x);

  def value(x: Double): Double = pnorms(x);
}

object CodyInlinedCND extends Function1D {

  private final val DBL_EPSILON = Epsilon.MACHINE_EPSILON; //2.2204460492503131e-16;
  private final val DBL_MIN = Double.MinValue; //2.2250738585072014e-308;

  private final val c0 = 0.39894151208813466764
  val c1 = 8.8831497943883759412
  val c2 = 93.506656132177855979
  val c3 = 597.27027639480026226
  val c4 = 2494.5375852903726711
  val c5 = 6848.1904505362823326
  val c6 = 11602.651437647350124
  val c7 = 9842.7148383839780218
  val c8 = 1.0765576773720192317e-8

  private final val d0 = 22.266688044328115691
  val d1 = 235.38790178262499861
  val d2 = 1519.377599407554805
  val d3 = 6485.558298266760755
  val d4 = 18615.571640885098091
  val d5 = 34900.952721145977266
  val d6 = 38912.003286093271411
  val d7 = 19685.429676859990727

  private final val p0 = 0.21589853405795699
  val p1 = 0.1274011611602473639
  val p2 = 0.022235277870649807
  val p3 = 0.001421619193227893466
  val p4 = 2.9112874951168792e-5
  val p5 = 0.02307344176494017303

  private final val q0 = 1.28426009614491121
  val q1 = 0.468238212480865118
  val q2 = 0.0659881378689285515
  val q3 = 0.00378239633202758244
  val q4 = 7.29751555083966205e-5

  private final val a0 = 2.2352520354606839287
  val a1 = 161.02823106855587881
  val a2 = 1067.6894854603709582
  val a3 = 18154.981253343561249
  val a4 = 0.065682337918207449113

  private final val b0 = 47.20258190468824187
  val b1 = 976.09855173777669322
  val b2 = 10260.932208618978205
  val b3 = 45507.789335026729956

  final val one = 1.0;
  final val half = 0.5;
  final val zero = 0.0;
  final val sixten = 1.6;
  final val sqrpi = 0.39894228040143267794;
  final val thrsh = 0.66291;
  final val root32 = 5.656854248;

  def pnorms(x: Double): Double = {

    var xden: Double = 0;
    var temp: Double = 0;
    var xnum: Double = 0;
    var result: Double = 0;
    var ccum: Double = 0;
    val min = DBL_MIN;
    val eps = DBL_EPSILON * .5;
    var xsq: Double = 0;
    var y: Double = 0;

    y = Math.abs(x);
    if (y <= thrsh) {
      /* Evaluate pnorm for |z| <= 0.66291 */
      xsq = zero;
      if (y > eps) {
        xsq = x * x;
      }
      xnum = a4 * xsq;
      xden = xsq;
      xnum = (xnum + a0) * xsq
      xden = (xden + b0) * xsq;
      xnum = (xnum + a1) * xsq
      xden = (xden + b1) * xsq;
      xnum = (xnum + a2) * xsq
      xden = (xden + b2) * xsq;

      result = x * (xnum + a3) / (xden + b3);
      temp = result;
      result = half + temp;
      ccum = half - temp;
    } else if (y <= root32) {
      /* Evaluate pnorm for 0.66291 <= |z| <= sqrt(32) */
      xnum = c8 * y;
      xden = y;
      xnum = (xnum + c0) * y;
      xden = (xden + d0) * y;
      xnum = (xnum + c1) * y;
      xden = (xden + d1) * y;
      xnum = (xnum + c2) * y;
      xden = (xden + d2) * y;
      xnum = (xnum + c3) * y;
      xden = (xden + d3) * y;
      xnum = (xnum + c4) * y;
      xden = (xden + d4) * y;
      xnum = (xnum + c5) * y;
      xden = (xden + d5) * y;
      xnum = (xnum + c6) * y;
      xden = (xden + d6) * y;

      result = (xnum + c7) / (xden + d7);

      result = NormalDistribution.denormalizedValue(y) * result;
      ccum = one - result;
      if (x > zero) {
        temp = result;
        result = ccum;
        ccum = temp;
      }
    } else {
      /* Evaluate pnorm for |z| > sqrt(32) */
      result = zero;
      xsq = one / (x * x);
      xnum = p5 * xsq;
      xden = xsq;
      xnum = (xnum + p0) * xsq;
      xden = (xden + q0) * xsq;
      xnum = (xnum + p1) * xsq;
      xden = (xden + q1) * xsq;
      xnum = (xnum + p2) * xsq;
      xden = (xden + q2) * xsq;
      xnum = (xnum + p3) * xsq;
      xden = (xden + q3) * xsq;

      result = xsq * (xnum + p4) / (xden + q4);
      result = (sqrpi - result) / y;
      result *= NormalDistribution.denormalizedValue(y)
      ccum = one - result;
      if (x > zero) {
        temp = result;
        result = ccum;
        ccum = temp;
      }
    }
    if (result < min) {
      result = 0.0;
    }
    if (ccum < min) {
      ccum = 0.0;
    }
    return result;
  }

  private def fint(x: Double): Double =

    if (x >= 0.0) StrictMath.floor(x) else -StrictMath.floor(-x);

  def value(x: Double): Double = pnorms(x);
}

/**
 * The original Hill AS66 algorithm (without Alan Miller mistakes)
 */
object HillAS66CND extends Function1D {
  val CON = 1.28d
  val HALF = 0.5d
  //original val LTONE = 5.0d
  val ONE = 1.0d

  //original,val UTZERO = 12.5d 
  val ZERO = 0.0d

  //proposed by Hill in AS66
  val LTONE = 8.3
  val UTZERO = 37.52

  def value(X: Double): Double = {
    var Z = X
    var alnorm = 0.0
    var up = false
    if (Z < 0) {
      up = !up
      Z = -Z
    }
    if (Z <= LTONE || up && Z <= UTZERO) {
      var Y = HALF * Z * Z
      if (Z >= CON) {
        alnorm = 0.398942280385e0 * math.exp(-Y) /
          (Z - 3.8052e-8 + 1.00000615302e0 /
            (Z + 3.98064794e-4 + 1.98615381364e0 /
              (Z - 0.151679116635e0 + 5.29330324926e0 /
                (Z + 4.8385912808e0 - 15.1508972451e0 /
                  (Z + 0.742380924027e0 + 30.789933034e0 /
                    (Z + 3.99019417011e0))))))
      } else {
        alnorm = HALF - Z * (0.398942280444e0 - 0.399903438504e0 * Y /
          (Y + 5.75885480458e0 - 29.8213557808e0 /
            (Y + 2.62433121679e0 + 48.6959930692e0 /
              (Y + 5.92885724438e0))))
      }
    } else {
      alnorm = 0.0
    }

    if (!up) {
      alnorm = 1.0 - alnorm
    }
    return alnorm
  }
}

object SchonfelderCND extends Function1D {
  val RTWO = 1.414213562373095048801688724209e0
  val IM = 24
  val A = Array[Double](
    6.10143081923200417926465815756E-1, -4.34841272712577471828182820888E-1, 1.76351193643605501125840298123E-1, -6.0710795609249414860051215825E-2, 1.7712068995694114486147141191E-2,
    -4.321119385567293818599864968E-3, 8.54216676887098678819832055E-4, -1.27155090609162742628893940E-4, 1.1248167243671189468847072E-5, 3.13063885421820972630152E-7,
    -2.70988068537762022009086E-7, 3.0737622701407688440959E-8, 2.515620384817622937314E-9, -1.028929921320319127590E-9, 2.9944052119949939363E-11, 2.6051789687266936290E-11,
    -2.634839924171969386E-12, -6.43404509890636443E-13, 1.12457401801663447E-13, 1.7281533389986098E-14, -4.264101694942375E-15, -5.45371977880191E-16, 1.58697607761671E-16,
    2.0899837844334E-17, -5.900526869409E-18, -9.41893387554E-19, 2.14977356470E-19, 4.6660985008E-20, -7.243011862E-21, -2.387966824E-21, 1.91177535E-22, 1.20482568E-22, -6.72377E-25,
    -5.747997E-24, -4.28493E-25, 2.44856E-25, 4.3793E-26, -8.151E-27, -3.089E-27, 9.3E-29, 1.74E-28, 1.6E-29, -8.0E-30, -2.0E-30)

  def value(x: Double): Double = phi(x)
  /*
         * Normal distribution probabilities accurate to 1d-15. Reference: J.L.
         * Schonfelder, Math Comp 32(1978), pp 1232-1240.
         */
  def phi(Z: Double): Double = {
    var I = 0;

    var BM, B, BP = 0.0;
    var P, T, XA = 0.0;

    XA = math.abs(Z) / RTWO;
    if (XA > 100) {
      P = 0;
    } else {
      T = (8 * XA - 30) / (4 * XA + 15);
      BM = 0;
      B = 0;
      //unroll loop
      //      A24 //BP=0, B=0
      //      T*A24 + A23 //BP=0 B=A_24
      //      T*(T*A24 + A23)-A24+A22//BP=A_24, B=T*A24+A23
      //      T*(T*(T*A24 + A23)-A24+A22)-T*A24 + A23+A21//BP=T*A24+A23, B=T*(T*A24 + A23)-A24+A22

      I = IM
      while (I >= 0) {
        BP = B;
        B = BM;
        BM = T * B - BP + A(I);
        I -= 1
      }
      P = NormalDistribution.denormalizedValue(Z) * (BM - BP) / 4;
      //      P = math.exp(-XA * XA) * (BM - BP) / 4;
    }
    if (Z > 0)
      P = 1 - P;
    return P;
  }
}

object OouraCND extends Function1D {
  val RTWO = 1.414213562373095048801688724209e0

  /**
   * Takuya OOURA, Research Institute for Mathematical Sciences Kyoto
   * University derfc function
   * http://www.kurims.kyoto-u.ac.jp/~ooura/gamerf.html
   *
   * @param x
   * @return
   */
  def derfcOoura(x: Double): Double = {
    val y = derfOuraUnscaled(x)
    return if (x < 0) 2 - y else y
  }

  private def derfOuraUnscaled(x: Double): Double = {

    val t = 3.97886080735226 / (Math.abs(x * 0.7071067811865475244008) + 3.97886080735226);
    val u = t - 0.5;
    var y = (((((((((0.00127109764952614092 * u + 1.19314022838340944e-4) * u - 0.003963850973605135) * u - 8.70779635317295828e-4) * u + 0.00773672528313526668) * u + 0.00383335126264887303) * u - 0.0127223813782122755) * u - 0.0133823644533460069) * u + 0.0161315329733252248) * u + 0.0390976845588484035) * u + 0.00249367200053503304;
    y = ((((((((((((y * u - 0.0838864557023001992) * u - 0.119463959964325415) * u + 0.0166207924969367356) * u + 0.357524274449531043) * u + 0.805276408752910567) * u + 1.18902982909273333) * u + 1.37040217682338167) * u + 1.31314653831023098) * u + 1.07925515155856677) * u + 0.774368199119538609) * u + 0.490165080585318424) * u + 0.275374741597376782) * t *
      NormalDistribution.denormalizedValue(x)
    //    NormalDistribution.denormalizedValue(x*RTWO)
    //    Math.exp(-x * x);
    return y;
  }

  def value(x: Double): Double = {
    val y = derfOuraUnscaled(x) // * 0.7071067811865475244008);
    return if (x < 0) 0.5 * y else 1 - 0.5 * y;
  }

}

object HartCND extends Function1D {
  val P0 = 220.2068679123761e0
  val P1 = 221.2135961699311e0
  val P2 = 112.0792914978709e0
  val P3 = 33.91286607838300e0
  val P4 = 6.373962203531650e0
  val P5 = .7003830644436881e0
  val P6 = .3526249659989109e-01
  val Q0 = 440.4137358247522e0
  val Q1 = 793.8265125199484e0
  val Q2 = 637.3336333788311e0
  val Q3 = 296.5642487796737e0
  val Q4 = 86.78073220294608e0
  val Q5 = 16.06417757920695e0
  val Q6 = 1.755667163182642e0
  val Q7 = .8838834764831844e-1
  val CUTOFF = 7.071e0
  val ROOT2PI = 2.506628274631001e0

  def value(Z: Double): Double = {
    val ZABS = math.abs(Z)
    //       |Z| > 37.
    if (ZABS > 37.0) {
      //          PDF = 0.D0
      if (Z > 0.0) {
        //            P = 1.D0
        return 1.0
        //            Q = 0.D0
      } else {
        return 0.0
        //P = 0.D0
        //Q = 1.D0
      }
    }
    //       |Z| <= 37.
    val EXPNTL = NormalDistribution.denormalizedValue(ZABS) //math.exp(-0.5 * ZABS * ZABS)
    val PDF = EXPNTL / ROOT2PI
    //       |Z| < CUTOFF = 10/sqrt(2).
    var P = 0.0
    if (ZABS < CUTOFF) {
      P = EXPNTL * ((((((P6 * ZABS + P5) * ZABS + P4) * ZABS + P3) * ZABS +
        P2) * ZABS + P1) * ZABS + P0) / (((((((Q7 * ZABS + Q6) * ZABS +
          Q5) * ZABS + Q4) * ZABS + Q3) * ZABS + Q2) * ZABS + Q1) * ZABS +
          Q0)
    } //       |Z| >= CUTOFF.
    else {
      P = PDF / (ZABS + 1.0 / (ZABS + 2.0 / (ZABS + 3.0 / (ZABS + 4.0 /
        (ZABS + 0.65)))))
    }
    if (Z < 0.0) {
      //          Q = 1.D0 - P
      return P
    } else {
      //          Q = P
      //          P = 1.D0 - Q
      return 1.0 - P
    }
  }

  //Hart is not all that precise in the left tail, the following improves it
  def improve(x: Double, cn: Double): Double = {
    if (x < 0 && cn <= Epsilon.MACHINE_EPSILON) {

      // use asymptotic abram and stegun (26.2.12)
      // Taken from quantlib, which takes from Peter Jackel's book
      var sum = 1.0;
      val xsqr = x * x;
      var i = 1
      var g = 1.0
      var z, y = 0.0
      var a = Double.MaxValue
      var lasta = 0.0
      do {
        lasta = a;
        z = (4 * i - 3) / xsqr;
        y = z * ((4 * i - 1) / xsqr);
        a = g * (z - y);
        sum -= a;
        g *= y;
        i += 1
        a = StrictMath.abs(a);
      } while (lasta > a && a >= StrictMath.abs(sum * Epsilon.MACHINE_EPSILON));
      //      println(i)
      return -(NormalDistribution.denormalizedValue(x) / ROOT2PI) / x * sum;
    }
    return cn
  }
}

object SunCND extends Function1D {

  // Coefficients for approximation to  erfc in [1.25,1/.35]
  val eRa = Array(
    -9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e01,
    -6.23753324503260060396e01,
    -1.62396669462573470355e02,
    -1.84605092906711035994e02,
    -8.12874355063065934246e01,
    -9.81432934416914548592e00)
  val eSa = Array(
    1.96512716674392571292e01,
    1.37657754143519042600e02,
    4.34565877475229228821e02,
    6.45387271733267880336e02,
    4.29008140027567833386e02,
    1.08635005541779435134e02,
    6.57024977031928170135e00,
    -6.04244152148580987438e-02)
  // Coefficients for approximation to  erfc in [1/.35,28]
  val eRb = Array(
    -9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e01,
    -1.60636384855821916062e02,
    -6.37566443368389627722e02,
    -1.02509513161107724954e03,
    -4.83519191608651397019e02)
  val eSb = Array(
    3.03380607434824582924e01,
    3.25792512996573918826e02,
    1.53672958608443695994e03,
    3.19985821950859553908e03,
    2.55305040643316442583e03,
    4.74528541206955367215e02,
    -2.24409524465858183362e01)
  val RTWO = 1.414213562373095048801688724209e0

  def value(z: Double): Double = {
//    return 0.5 * erfc(-x / RTWO)
    val x = -z/RTWO
    var s, retval, R, S: Double = 0.0
    val abs_x = if (x >= 0.0) x else -x;
    if (abs_x < 1.25)
      retval = 0.5*(1.0 - erf(abs_x));
    else if (abs_x > 28.0)
      retval = 0.0;
    else { // 1.25 < |x| < 28 
      s = 1.0 / (abs_x * abs_x);
      if (abs_x < 2.8571428) { // ( |x| < 1/0.35 ) 
        R = eRa(0) + s * (eRa(1) + s * (eRa(2) + s * (eRa(3) + s * (eRa(4) + s * (eRa(5) + s * (eRa(6) + s * eRa(7)))))));
        S = 1.0 + s * (eSa(0) + s * (eSa(1) + s * (eSa(2) + s * (eSa(3) + s * (eSa(4) + s * (eSa(5) + s * (eSa(6) + s * eSa(7))))))));
      } else { // ( |x| > 1/0.35 )
        R = eRb(0) + s * (eRb(1) + s * (eRb(2) + s * (eRb(3) + s * (eRb(4) + s * (eRb(5) + s * eRb(6))))));
        S = 1.0 + s * (eSb(0) + s * (eSb(1) + s * (eSb(2) + s * (eSb(3) + s * (eSb(4) + s * (eSb(5) + s * eSb(6)))))));
      }
      retval = NormalDistribution.denormalizedValue(z)*math.exp(- 0.5625 + R / S) *0.5/ abs_x;
    }
    return if (x >= 0.0) retval else 1.0 - retval
  }

  def erfc(x: Double): Double = {
    var s, retval, R, S: Double = 0.0
    val abs_x = if (x >= 0.0) x else -x;
    if (abs_x < 1.25)
      retval = 1.0 - erf(abs_x);
    else if (abs_x > 28.0)
      retval = 0.0;
    else { // 1.25 < |x| < 28 
      s = 1.0 / (abs_x * abs_x);
      if (abs_x < 2.8571428) { // ( |x| < 1/0.35 ) 
        R = eRa(0) + s * (eRa(1) + s * (eRa(2) + s * (eRa(3) + s * (eRa(4) + s * (eRa(5) + s * (eRa(6) + s * eRa(7)))))));
        S = 1.0 + s * (eSa(0) + s * (eSa(1) + s * (eSa(2) + s * (eSa(3) + s * (eSa(4) + s * (eSa(5) + s * (eSa(6) + s * eSa(7))))))));
      } else { // ( |x| > 1/0.35 )
        R = eRb(0) + s * (eRb(1) + s * (eRb(2) + s * (eRb(3) + s * (eRb(4) + s * (eRb(5) + s * eRb(6))))));
        S = 1.0 + s * (eSb(0) + s * (eSb(1) + s * (eSb(2) + s * (eSb(3) + s * (eSb(4) + s * (eSb(5) + s * eSb(6)))))));
      }
//      retval = NormalDistribution.denormalizedValue(x*RTWO)*math.exp(- 0.5625 + R / S) / abs_x;
      retval = math.exp(-x * x - 0.5625 + R / S) / abs_x;
    }
    return if (x >= 0.0) retval else 2.0 - retval
  }

  // ====================================================
  // Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
  //
  // Developed at SunSoft, a Sun Microsystems, Inc. business.
  // Permission to use, copy, modify, and distribute this
  // software is freely granted, provided that this notice 
  // is preserved.
  // ====================================================
  //
  //                           x
  //                    2      |\
  //     erf(x)  =  ---------  | exp(-t*t)dt
  //                 sqrt(pi) \| 
  //                           0
  //
  //     erfc(x) =  1-erf(x)
  //  Note that 
  //              erf(-x) = -erf(x)
  //              erfc(-x) = 2 - erfc(x)
  //
  // Method:
  //      1. For |x| in [0, 0.84375]
  //          erf(x)  = x + x*R(x^2)
  //          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
  //                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
  //         where R = P/Q where P is an odd poly of degree 8 and
  //         Q is an odd poly of degree 10.
  //                                               -57.90
  //                      | R - (erf(x)-x)/x | <= 2
  //      
  //
  //         Remark. The formula is derived by noting
  //          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
  //         and that
  //          2/sqrt(pi) = 1.128379167095512573896158903121545171688
  //         is close to one. The interval is chosen because the fix
  //         point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
  //         near 0.6174), and by some experiment, 0.84375 is chosen to
  //         guarantee the error is less than one ulp for erf.
  //
  //      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
  //         c = 0.84506291151 rounded to single (24 bits)
  //              erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
  //              erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
  //                        1+(c+P1(s)/Q1(s))    if x < 0
  //              |P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
  //         Remark: here we use the taylor series expansion at x=1.
  //              erf(1+s) = erf(1) + s*Poly(s)
  //                       = 0.845.. + P1(s)/Q1(s)
  //         That is, we use rational approximation to approximate
  //                      erf(1+s) - (c = (single)0.84506291151)
  //         Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
  //         where 
  //              P1(s) = degree 6 poly in s
  //              Q1(s) = degree 6 poly in s
  //
  //      3. For x in [1.25,1/0.35(~2.857143)], 
  //              erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
  //              erf(x)  = 1 - erfc(x)
  //         where 
  //              R1(z) = degree 7 poly in z, (z=1/x^2)
  //              S1(z) = degree 8 poly in z
  //
  //      4. For x in [1/0.35,28]
  //              erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
  //                      = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
  //                      = 2.0 - tiny            (if x <= -6)
  //              erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
  //              erf(x)  = sign(x)*(1.0 - tiny)
  //         where
  //              R2(z) = degree 6 poly in z, (z=1/x^2)
  //              S2(z) = degree 7 poly in z
  //
  //      Note1:
  //         To compute exp(-x*x-0.5625+R/S), let s be a single
  //         precision number and s := x; then
  //              -x*x = -s*s + (s-x)*(s+x)
  //              exp(-x*x-0.5626+R/S) = 
  //                      exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
  //      Note2:
  //         Here 4 and 5 make use of the asymptotic series
  //                        exp(-x*x)
  //              erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
  //                        x*sqrt(pi)
  //         We use rational approximation to approximate
  //              g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
  //         Here is the error bound for R1/S1 and R2/S2
  //              |R1/S1 - f(x)|  < 2**(-62.57)
  //              |R2/S2 - f(x)|  < 2**(-61.52)
  //
  //      5. For inf > x >= 28
  //              erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
  //              erfc(x) = tiny*tiny (raise underflow) if x > 0
  //                      = 2 - tiny if x<0
  //
  //      7. Special case:
  //              erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
  //              erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2, 
  //              erfc/erf(NaN) is NaN
  //

  // Coefficients for approximation to  erf on [0,0.84375]
  val e_efx = 1.28379167095512586316e-01;
  //double efx8=1.02703333676410069053e00;
  val ePp = Array(
    1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05)
  val eQq = Array(
    3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06)
  // Coefficients for approximation to  erf  in [0.84375,1.25] 
  val ePa = Array(
    -2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03)
  val eQa = Array(
    1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02)
  val e_erx = 8.45062911510467529297e-01

  /**
   * Error function.
   * Based on C-code for the error function developed at Sun Microsystems.
   * @author Jaco van Kooten
   */
  def erf(x: Double): Double = {

    var P, Q, s, retval: Double = 0.0
    val abs_x = if (x >= 0.0) x else -x
    if (abs_x < 0.84375) { // 0 < |x| < 0.84375
      if (abs_x < 3.7252902984619141e-9) // |x| < 2**-28
        retval = abs_x + abs_x * e_efx;
      else {
        s = x * x;
        P = ePp(0) + s * (ePp(1) + s * (ePp(2) + s * (ePp(3) + s * ePp(4))));
        Q = 1.0 + s * (eQq(0) + s * (eQq(1) + s * (eQq(2) + s * (eQq(3) + s * eQq(4)))));
        retval = abs_x + abs_x * (P / Q);
      }
    } else if (abs_x < 1.25) { // 0.84375 < |x| < 1.25
      s = abs_x - 1.0;
      P = ePa(0) + s * (ePa(1) + s * (ePa(2) + s * (ePa(3) + s * (ePa(4) + s * (ePa(5) + s * ePa(6))))));
      Q = 1.0 + s * (eQa(0) + s * (eQa(1) + s * (eQa(2) + s * (eQa(3) + s * (eQa(4) + s * eQa(5))))));
      retval = e_erx + P / Q;
    } else if (abs_x >= 6.0)
      retval = 1.0;
    else // 1.25 < |x| < 6.0 
      retval = 1.0 - erfc(abs_x);
    return if (x >= 0.0) retval else -retval
  }
}

object CumulativeNormalDistribution extends Function1D {
  /**
   * tip: transform to -x for x big as there is more precision around 0 than around 1.
   */
  def value(x: Double): Double = {
    return CodyCND.pnorms(x);
  }

}